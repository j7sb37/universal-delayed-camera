<!--
  Universal Delayed Camera
  Author: Sami M
  Assistance: Powered by ChatGPT (OpenAI)
-->

<!DOCTYPE html>
<html lang="fi">
<head>
<meta charset="UTF-8">
<title>Universal Delayed Camera</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    background: black;
    font-family: sans-serif;
    overflow: hidden;
  }

  #canvas {
    display: block;
    width: 100%;
    height: calc(100vh - 60px); /* tilaa valikolle */
    object-fit: contain; /* säilyttää kuvasuhteen */
    background: black;
  }

  .controls {
    width: 100%;
    height: 60px;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
    gap: 10px;
    background: rgba(0,0,0,0.8);
    color: white;
    font-size: 14px;
    padding: 5px 0;
    box-sizing: border-box;
    z-index: 100;
    position: relative;
  }

  .controls input, .controls select {
    padding: 4px 6px;
    border-radius: 4px;
    border: 1px solid #666;
    background: #222;
    color: #fff;
    font-size: 14px;
  }

  .controls button {
    padding: 5px 12px;
    border-radius: 4px;
    border: none;
    font-weight: bold;
    cursor: pointer;
    transition: 0.2s;
    text-transform: uppercase;
  }

  #startBtn { background: #4CAF50; color: white; }
  #saveBtn { background: #f44336; color: white; }
  #stopBtn { background: #FF5722; color: white; }
  #fullscreenBtn { background: #2196F3; color: white; }
  .controls button:hover { opacity: 0.8; }

  #status {
    position: absolute;
    bottom: 20px;
    left: 20px;
    font-family: monospace;
    font-size: 16px;
    color: #00ff00;
    background: rgba(0,0,0,0.6);
    padding: 8px 12px;
    border-radius: 6px;
    z-index: 10;
    pointer-events: none;
  }
</style>
</head>
<body>

<div class="controls">
  Viive(s): <input type="number" id="delay" value="5" min="1" max="15" style="width: 40px;">
  Tallennus(s): <input type="number" id="recordLength" value="10" min="1" style="width: 40px;">
  Aloitus(s): <input type="number" id="startBefore" value="-5" min="-15" max="0" style="width: 40px;">
  
  <select id="cameraRes">
    <option value="640x480">480p</option>
    <option value="1280x720" selected>720p</option>
    <option value="1920x1080">1080p</option>
    <option value="2560x1440">2K</option>
    <option value="3840x2160">4K</option>
  </select>
  
  <select id="fpsSelect">
    <option value="30" selected>30 FPS</option>
    <option value="60">60 FPS</option>
  </select>
  
  <select id="cameraSelect" style="max-width: 150px;">
    <option value="default">Etsitään kameroita...</option>
  </select>
  
  <button id="startBtn">Start</button>
  <button id="saveBtn">Save</button>
  <button id="stopBtn">Stop</button>
  <button id="fullscreenBtn">Full</button>
</div>

<canvas id="canvas"></canvas>
<div id="status">Käynnistä sovellus...</div>
<video id="video" autoplay playsinline style="display:none;"></video>

<script>
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha:false });
const statusDiv = document.getElementById('status');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const cameraSelect = document.getElementById('cameraSelect');

let frameBuffer=[];
let mediaStream=null;
let fps=30;
let isRunning=false;
let lastFrameTime = 0;

function getParams(){
  return {
    delay: parseFloat(document.getElementById('delay').value)||5,
    recordLength: parseFloat(document.getElementById('recordLength').value)||10,
    startBefore: parseFloat(document.getElementById('startBefore').value)||-5,
    res: document.getElementById('cameraRes').value.split('x').map(Number),
    fps: parseInt(document.getElementById('fpsSelect').value)
  };
}

// 1. Alustus: Pyydetään lupa ja haetaan kamerat
async function initCameras() {
  statusDiv.innerText = "Haetaan kameroita...";
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    stream.getTracks().forEach(track => track.stop());

    const devices = await navigator.mediaDevices.enumerateDevices();
    const videoDevices = devices.filter(device => device.kind === 'videoinput');

    cameraSelect.innerHTML = '';
    videoDevices.forEach((device, index) => {
      const option = document.createElement('option');
      option.value = device.deviceId;
      option.text = device.label || `Kamera ${index + 1}`;
      cameraSelect.appendChild(option);
    });

    statusDiv.innerText = "Kamerat löydetty. Valmis.";
  } catch (err) {
    statusDiv.innerText = "Salli kameran käyttö selaimesta.";
  }
}

// 2. Käynnistys
document.getElementById('startBtn').onclick = async () => {
  const params = getParams();
  fps = params.fps;

  if (mediaStream) {
    mediaStream.getTracks().forEach(track => track.stop());
  }

  const constraints = {
    video: {
      width: { ideal: params.res[0] },
      height: { ideal: params.res[1] },
      frameRate: { ideal: fps }
    }
  };

  const cameraId = cameraSelect.value;
  if (cameraId && cameraId !== 'default' && cameraId.length > 5) {
    constraints.video.deviceId = { exact: cameraId };
  }

  try {
    mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
    startVideoProcessing();
  } catch {
    mediaStream = await navigator.mediaDevices.getUserMedia({ video: true });
    startVideoProcessing();
  }
};

function startVideoProcessing() {
  video.srcObject = mediaStream;
  video.onloadedmetadata = () => {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    frameBuffer = [];
    isRunning = true;
    requestAnimationFrame(processVideo);
  };
}

function processVideo(timestamp) {
  if (!isRunning) return;

  const frameDuration = 1000 / fps;
  if (timestamp - lastFrameTime >= frameDuration) {
    lastFrameTime = timestamp;

    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
    tempCanvas.getContext('2d').drawImage(video, 0, 0);

    frameBuffer.push(tempCanvas);

    const params = getParams();
    const maxBuffer = fps * (params.delay + Math.abs(params.startBefore) + 10);
    if (frameBuffer.length > maxBuffer) frameBuffer.shift();

    const delayFrames = Math.floor(fps * params.delay);
    if (frameBuffer.length >= delayFrames) {
      ctx.drawImage(frameBuffer[frameBuffer.length - delayFrames], 0, 0);
      drawClock(ctx);
    }
  }

  requestAnimationFrame(processVideo);
}

function drawClock(c){
  const now = new Date();

  const dd   = String(now.getDate()).padStart(2,'0');
  const mm   = String(now.getMonth() + 1).padStart(2,'0');
  const yyyy = now.getFullYear();
  const hh   = String(now.getHours()).padStart(2,'0');
  const min  = String(now.getMinutes()).padStart(2,'0');
  const ss   = String(now.getSeconds()).padStart(2,'0');
  const t = Math.floor(now.getMilliseconds() / 100);

  const timeStr = `${dd}-${mm}-${yyyy} ${hh}:${min}:${ss}.${t}`;

  c.font = '20px monospace';
  c.textBaseline = 'alphabetic';

  const paddingX = 8;
  const paddingY = 6;
  const metrics = c.measureText(timeStr);
  const textHeight = 20;
  const boxWidth = Math.ceil(metrics.width) + paddingX * 2;
  const boxHeight = textHeight + paddingY * 2;

  const x = 10;
  const y = canvas.height - 10;

  c.fillStyle = 'rgba(0,0,0,0.6)';
  c.fillRect(x - paddingX, y - textHeight - paddingY, boxWidth, boxHeight);

  c.fillStyle = '#00ff00';
  c.fillText(timeStr, x, y);
}

/* ===================================================
   VAIN TALLENNUKSEN AJASTUS KORJATTU
   =================================================== */

document.getElementById('saveBtn').onclick = () => {
  const params = getParams();
  const currentFPS = fps;

  const visibleIdx = frameBuffer.length - Math.floor(currentFPS * params.delay);
  const startIndex = visibleIdx + Math.floor(currentFPS * params.startBefore);
  const totalFrames = Math.floor(currentFPS * params.recordLength);

  if (startIndex < 0) {
    alert("Odota hetki, puskurissa ei ole vielä tarpeeksi historiaa tallennukseen!");
    return;
  }

  statusDiv.innerText = "Valmistellaan tallennusta...";

  const recordCanvas = document.createElement('canvas');
  recordCanvas.width = canvas.width;
  recordCanvas.height = canvas.height;
  const rCtx = recordCanvas.getContext('2d', { alpha: false });

  const stream = recordCanvas.captureStream(currentFPS);
  const recorder = new MediaRecorder(stream, {
    mimeType: 'video/webm; codecs=vp8',
    videoBitsPerSecond: 8000000
  });

  const chunks = [];
  recorder.ondataavailable = e => chunks.push(e.data);
  recorder.onstop = () => {
    const blob = new Blob(chunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);

    const now = new Date();
    const fileName =
      `delayed_video_${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}_${now.getHours()}-${now.getMinutes()}-${now.getSeconds()}.webm`;

    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    a.click();
    URL.revokeObjectURL(url);
    statusDiv.innerText = "Video tallennettu!";
  };

  recorder.start();

  let framesProcessed = 0;
  let lastTime = performance.now();
  const frameDuration = 1000 / currentFPS;

  function recordLoop(now) {
    if (framesProcessed >= totalFrames) {
      recorder.stop();
      return;
    }

    if (now - lastTime >= frameDuration) {
      lastTime += frameDuration;

      const idx = startIndex + framesProcessed;
      const f = frameBuffer[idx];
      if (f) {
        rCtx.drawImage(f, 0, 0);
        drawClock(rCtx);
      }

      framesProcessed++;
      if (framesProcessed % 10 === 0) {
        statusDiv.innerText =
          `Tallennetaan: ${Math.round((framesProcessed / totalFrames) * 100)}%`;
      }
    }

    requestAnimationFrame(recordLoop);
  }

  requestAnimationFrame(recordLoop);
};

document.getElementById('stopBtn').onclick = () => {
  if (mediaStream) {
    mediaStream.getTracks().forEach(track => track.stop());
    statusDiv.innerText = "Kamera pysäytetty";
    isRunning = false;
  }
};

fullscreenBtn.onclick = () => {
  if (!document.fullscreenElement) {
    canvas.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
};

initCameras();
</script>
</body>
</html>
