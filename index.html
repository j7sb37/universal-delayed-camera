<!--
  Universal Delayed Camera
  Author: Sami M
  Assistance: Powered by ChatGPT (OpenAI)
-->

<!DOCTYPE html>
<html lang="fi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Universal Delayed Camera - Final Pro</title>
<style>
  body, html {
  margin: 0;
  padding: 0;
  background: black;
  font-family: sans-serif;
  overflow: hidden;

  /* YHTEENSOPIVA KAIKILLA LAITTEILLA */
  height: 100%;
  min-height: 100vh;

  display: flex;
  flex-direction: column;
  }
  #canvas { display: block; width: 100vw; flex-grow: 1; object-fit: contain; background: #000; }
  .controls { width: 100%; min-height: 80px; display: flex; flex-wrap: wrap; align-items: center; justify-content: center; gap: 6px; background: #222; color: white; font-size: 11px; padding: 5px; box-sizing: border-box; border-bottom: 1px solid #444; z-index: 20; }
  .controls input, .controls select { padding: 4px; border-radius: 4px; border: 1px solid #444; background: #333; color: white; }
  .controls {
  flex-shrink: 0;
  }
  button { padding: 8px 12px; border-radius: 4px; border: none; font-weight: bold; cursor: pointer; text-transform: uppercase; font-size: 10px; }
  #startBtn { background: #4CAF50; color: white; }
  #saveBtn { background: #f44336; color: white; }
  #stopBtn { background: #555; color: white; }
  #fullBtn { background: #2196F3; color: white; }
  #status { position: absolute; top: 90px; left: 10px; font-family: monospace; color: #00ff00; background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 4px; pointer-events: none; z-index: 10; }
  #info { position: absolute; top: 90px; right: 10px; font-family: monospace; color: white; background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px; z-index: 10; }
</style>
</head>
<body>

<div class="controls">
  <span>Viive: <input type="number" id="delay" value="5" style="width: 35px;">s</span>
  <span>Kesto: <input type="number" id="recordLength" value="15" style="width: 35px;">s</span>
  <span>Alku: <input type="number" id="startBefore" value="-15" style="width: 35px;">s</span>

  <select id="cameraRes">
    <option value="640x480">640x480</option>
    <option value="1280x720" selected>1280x720</option>
    <option value="1920x1080">1920x1080</option>
  </select>

  <select id="fpsSelect">
    <option value="30" selected>30 FPS</option>
    <option value="60">60 FPS</option>
  </select>

  <select id="cameraSelect" style="max-width: 100px;"></select>

  <button id="startBtn">Start</button>
  <button id="saveBtn">Save</button>
  <button id="stopBtn">Stop</button>
  <button id="fullBtn">Full</button>
</div>

<div id="info">Res: - | measuredFPS: -</div>
<div id="status">Paina Start</div>

<canvas id="canvas"></canvas>
<video id="video" autoplay playsinline muted style="position:fixed; top:-100px; left:-100px; width:640px; height:480px; opacity:0; pointer-events:none;"></video>

<script>
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const statusDiv = document.getElementById('status');
const infoDiv = document.getElementById('info');
const cameraSelect = document.getElementById('cameraSelect');

let frameBuffer = [];
let isRunning = false;
let mediaStream = null;
let targetFPS = 30;
let currentMeasuredFPS = 0;
let lastTick = 0;
let frameCount = 0;
let lastFpsUpdate = 0;

async function init() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    const devices = await navigator.mediaDevices.enumerateDevices();
    cameraSelect.innerHTML = devices.filter(d => d.kind === 'videoinput').map((d, i) =>
      `<option value="${d.deviceId}">${d.label || 'Kamera ' + (i + 1)}</option>`
    ).join('');
    stream.getTracks().forEach(t => t.stop());
  } catch {
    statusDiv.innerText = "Salli kamera.";
  }
}

function startMainLoop() {
  if (isRunning) return;
  if (video.videoWidth > 0) {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    frameBuffer = [];
    isRunning = true;
    lastTick = performance.now();
    statusDiv.innerText = "Käynnissä.";
    requestAnimationFrame(mainLoop);
  } else {
    setTimeout(startMainLoop, 100);
  }
}

document.getElementById('startBtn').onclick = async () => {
  isRunning = false;
  if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
  targetFPS = parseInt(document.getElementById('fpsSelect').value);
  const res = document.getElementById('cameraRes').value.split('x').map(Number);
  statusDiv.innerText = "Käynnistetään...";
  try {
    mediaStream = await navigator.mediaDevices.getUserMedia({
      video: {
        deviceId: cameraSelect.value ? { exact: cameraSelect.value } : undefined,
        width: { ideal: res[0] },
        height: { ideal: res[1] },
        frameRate: { ideal: targetFPS }
      }
    });
    video.srcObject = mediaStream;
    video.play();
    video.onplaying = () => startMainLoop();
    setTimeout(startMainLoop, 1000);
  } catch (e) {
    statusDiv.innerText = "Virhe: " + e.message;
  }
};

function mainLoop(now) {
  if (!isRunning) return;
  const interval = 1000 / targetFPS;
  if (now - lastTick >= interval) {
    lastTick = now;
    frameCount++;
    if (now - lastFpsUpdate >= 1000) {
      currentMeasuredFPS = frameCount;
      infoDiv.innerText = `Res: ${canvas.width}x${canvas.height} | measuredFPS: ${currentMeasuredFPS}`;
      frameCount = 0;
      lastFpsUpdate = now;
    }

    const f = document.createElement('canvas');
    f.width = canvas.width;
    f.height = canvas.height;
    f.getContext('2d', { alpha: false }).drawImage(video, 0, 0);
    frameBuffer.push(f);

    const dS = Math.abs(parseFloat(document.getElementById('delay').value));
    const aS = Math.abs(parseFloat(document.getElementById('startBefore').value));
    const kS = parseFloat(document.getElementById('recordLength').value);
    const maxFrames = targetFPS * (dS + aS + kS + 2);

    while (frameBuffer.length > maxFrames) frameBuffer.shift();

    const displayIdx = frameBuffer.length - 1 - Math.floor(targetFPS * dS);
    if (frameBuffer[displayIdx]) {
      ctx.drawImage(frameBuffer[displayIdx], 0, 0);
      drawClock(ctx);
    }
  }
  requestAnimationFrame(mainLoop);
}

function drawClock(c) {
  const n = new Date();
  const full = `${n.getDate()}.${String(n.getMonth()+1).padStart(2,'0')}.${n.getFullYear()} ${String(n.getHours()).padStart(2,'0')}:${String(n.getMinutes()).padStart(2,'0')}:${String(n.getSeconds()).padStart(2,'0')}.${Math.floor(n.getMilliseconds()/100)}`;
  c.font = '22px monospace';
  c.fillStyle = 'rgba(0,0,0,0.7)';
  const tw = c.measureText(full).width;
  c.fillRect(10, canvas.height - 40, tw + 20, 30);
  c.fillStyle = '#00ff00';
  c.fillText(full, 20, canvas.height - 18);
}

/* =======================
   AINOA KORJATTU OSA
   ======================= */
document.getElementById('saveBtn').onclick = async () => {
  if (frameBuffer.length < 10) return;
  statusDiv.innerText = "Tallennetaan...";

  const saveFPS = currentMeasuredFPS > 5 ? currentMeasuredFPS : targetFPS;

  const delay = parseFloat(document.getElementById('delay').value);
  const startBefore = parseFloat(document.getElementById('startBefore').value);
  const recordLength = parseFloat(document.getElementById('recordLength').value);

  // Nykyhetken (näytöllä oleva) frame
  const displayIdx = frameBuffer.length - 1 - Math.round(delay * saveFPS);

  // Tallennuksen aloitus MENNEISYYDESSÄ
  const startIdx =
    displayIdx - Math.round((-startBefore) * saveFPS);

  const framesNeeded = Math.round(recordLength * saveFPS);
  const endIdxTarget = startIdx + framesNeeded - 1;

  // ODOTA kunnes tulevaisuuden framet ovat olemassa
  while (frameBuffer.length - 1 < endIdxTarget) {
    statusDiv.innerText = "Odotetaan tulevia frameja...";
    await new Promise(r => setTimeout(r, 20));
  }

  const framesToSave = frameBuffer.slice(startIdx, endIdxTarget + 1);

  if (framesToSave.length !== framesNeeded) {
    statusDiv.innerText = "Tallennus epäonnistui!";
    return;
  }

  const outCanvas = document.createElement('canvas');
  outCanvas.width = canvas.width;
  outCanvas.height = canvas.height;
  const oCtx = outCanvas.getContext('2d', { alpha: false });

  const stream = outCanvas.captureStream(saveFPS);
  const recorder = new MediaRecorder(stream, {
    mimeType: 'video/webm;codecs=vp8',
    videoBitsPerSecond: 12000000
  });

  const chunks = [];
  recorder.ondataavailable = e => chunks.push(e.data);
  recorder.onstop = () => {
    const d = new Date();
    const ts =
      `delayed-camera_${d.getFullYear()}-` +
      `${String(d.getMonth()+1).padStart(2,'0')}-` +
      `${String(d.getDate()).padStart(2,'0')}-` +
      `${String(d.getHours()).padStart(2,'0')}-` +
      `${String(d.getMinutes()).padStart(2,'0')}-` +
      `${String(d.getSeconds()).padStart(2,'0')}`;

    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob(chunks, { type: 'video/webm' }));
    a.download = `${ts}.webm`;
    a.click();
    statusDiv.innerText = "Valmis!";
  };

  recorder.start();
  let i = 0;
  const saveTimer = setInterval(() => {
    if (i >= framesToSave.length) {
      clearInterval(saveTimer);
      setTimeout(() => recorder.stop(), 500);
      return;
    }
    oCtx.drawImage(framesToSave[i], 0, 0);
    drawClock(oCtx);
    i++;
    statusDiv.innerText = `Käsittely: ${Math.round((i/framesToSave.length)*100)}%`;
  }, 1000 / saveFPS);
};

document.getElementById('stopBtn').onclick = () => {
  isRunning = false;
  if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
  statusDiv.innerText = "Pysäytetty.";
};

document.getElementById('fullBtn').onclick = () => {
  if (!document.fullscreenElement) canvas.requestFullscreen();
  else document.exitFullscreen();
};

init();
</script>
</body>
</html>
